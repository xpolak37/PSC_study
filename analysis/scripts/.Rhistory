pp_cov <- pp_main[[2]]
pp_fac.cov <- pp_int[[3]]
cols <- c("pairs","Df","SumsOfSqs", "F.Model","R2","p.value", "p.adjusted", "sig")
colnames(pp_factor) <- cols; colnames(pp_cov) <- cols; colnames(pp_fac.cov) <- cols;
# save raw results
pairwise_aitchison_raw <- list()
pairwise_aitchison_raw[["Genus ileum"]] <-rbind(pp_factor,pp_cov,pp_fac.cov)
# see the results
knitr::kable(pp_factor,digits = 3,caption = "PERMANOVA, GROUP separation")
knitr::kable(pp_cov,digits = 3,caption = "PERMANOVA, COUNTRY separation")
knitr::kable(pp_fac.cov,digits = 3,caption = "PERMANOVA, INTERACTION GROUP:Country")
interaction_sig <- pp_fac.cov$pairs[pp_fac.cov$p.adjusted < 0.05]
for (i in 1:length(interaction_sig)){
group1 <- unlist(strsplit(interaction_sig[i],split = " vs "))[1]
group2 <- unlist(strsplit(interaction_sig[i],split = " vs "))[2]
group2 <- unlist(strsplit(group2,split = " : "))[1]
result_list <- adonis_postanalysis(x=pairwise_df,
factors = filt_ileum_metadata$Group,
covariate = filt_ileum_metadata$Country,
group1 = group1,
group2 = group2)
print(result_list)
}
pca_plots_list <- list()
p <- pca_plot_custom(filt_ileum_genus_tab,
filt_ileum_genus_taxa,
filt_ileum_metadata,
show_boxplots = TRUE,
variable = "Group", size=3, show_legend=TRUE)
# save the results
pca_plots_list[["Q1 Ileum Genus custom"]] <- p
# see the results
p
supplements <- list()
pairwise_df <- filt_ileum_genus_tab %>% column_to_rownames("SeqID") %>% t()
# main effect
pp_main <- pairwise.adonis(pairwise_df,filt_ileum_metadata$Group,covariate = filt_ileum_metadata$Country, sim.function = "bray", p.adjust.m="BH")
# interaction
pp_int <- pairwise.adonis(pairwise_df,filt_ileum_metadata$Group,covariate = filt_ileum_metadata$Country, interaction = TRUE, sim.function = "bray", p.adjust.m="BH")
# tidy the results
pp_factor <- pp_main[[1]]
pp_cov <- pp_main[[2]]
pp_fac.cov <- pp_int[[3]]
cols <- c("pairs","Df","SumsOfSqs", "F.Model","R2","p.value", "p.adjusted", "sig")
colnames(pp_factor) <- cols; colnames(pp_cov) <- cols; colnames(pp_fac.cov) <- cols;
# save raw results
supplements[["PERMANOVA Bray Genus Ileum"]] <-rbind(pp_factor,pp_cov,pp_fac.cov)
# see the results
knitr::kable(pp_factor,digits = 3,caption = "PERMANOVA, GROUP separation")
knitr::kable(pp_cov,digits = 3,caption = "PERMANOVA, COUNTRY separation")
knitr::kable(pp_fac.cov,digits = 3,caption = "PERMANOVA, INTERACTION GROUP:Country")
interaction_sig <- pp_fac.cov$pairs[pp_fac.cov$p.adjusted < 0.05]
for (i in 1:length(interaction_sig)){
group1 <- unlist(strsplit(interaction_sig[i],split = " vs "))[1]
group2 <- unlist(strsplit(interaction_sig[i],split = " vs "))[2]
group2 <- unlist(strsplit(group2,split = " : "))[1]
result_list <- adonis_postanalysis(x=pairwise_df,
factors = filt_ileum_metadata$Group,
covariate = filt_ileum_metadata$Country,
group1 = group1,
group2 = group2,
sim.method = 'bray')
print(result_list)
}
p <- pca_plot_custom(filt_ileum_genus_tab,
filt_ileum_genus_taxa,
filt_ileum_metadata,
measure = "bray",
show_boxplots = TRUE,
variable = "Group", size=3, show_legend=TRUE)
# save the results
supplements[["PCoA Bray Ileum Genus"]] <- p
# see the results
p
pairwise_df <- filt_ileum_genus_tab %>% column_to_rownames("SeqID") %>% t()
# main effect
pp_main <- pairwise.adonis(pairwise_df,filt_ileum_metadata$Group,covariate = filt_ileum_metadata$Country, sim.function = "jaccard", p.adjust.m="BH")
# interaction
pp_int <- pairwise.adonis(pairwise_df,filt_ileum_metadata$Group,covariate = filt_ileum_metadata$Country, interaction = TRUE, sim.function = "jaccard", p.adjust.m="BH")
# tidy the results
pp_factor <- pp_main[[1]]
pp_cov <- pp_main[[2]]
pp_fac.cov <- pp_int[[3]]
cols <- c("pairs","Df","SumsOfSqs", "F.Model","R2","p.value", "p.adjusted", "sig")
colnames(pp_factor) <- cols; colnames(pp_cov) <- cols; colnames(pp_fac.cov) <- cols;
# save raw results
supplements[["PERMANOVA Jaccard Genus Ileum"]] <-rbind(pp_factor,pp_cov,pp_fac.cov)
# see the results
knitr::kable(pp_factor,digits = 3,caption = "PERMANOVA, GROUP separation")
knitr::kable(pp_cov,digits = 3,caption = "PERMANOVA, COUNTRY separation")
knitr::kable(pp_fac.cov,digits = 3,caption = "PERMANOVA, INTERACTION GROUP:Country")
interaction_sig <- pp_fac.cov$pairs[pp_fac.cov$p.adjusted < 0.05]
for (i in 1:length(interaction_sig)){
group1 <- unlist(strsplit(interaction_sig[i],split = " vs "))[1]
group2 <- unlist(strsplit(interaction_sig[i],split = " vs "))[2]
group2 <- unlist(strsplit(group2,split = " : "))[1]
result_list <- adonis_postanalysis(x=pairwise_df,
factors = filt_ileum_metadata$Group,
covariate = filt_ileum_metadata$Country,
group1 = group1,
group2 = group2,
sim.method = 'jaccard')
print(result_list)
}
p <- pca_plot_custom(filt_ileum_genus_tab,
filt_ileum_genus_taxa,
filt_ileum_metadata,
measure = "jaccard",
show_boxplots = TRUE,
variable = "Group", size=3, show_legend=TRUE)
# save the results
supplements[["PCoA Jaccard Ileum Genus"]] <- p
# see the results
p
# preparing data frame
pairwise_df <- filt_ileum_asv_tab %>% column_to_rownames("SeqID") %>% t()
# main effect
pp_main <- pairwise.adonis(pairwise_df,filt_ileum_metadata$Group,covariate = filt_ileum_metadata$Country, sim.function = "robust.aitchison", p.adjust.m="BH")
# interaction
pp_int <- pairwise.adonis(pairwise_df,filt_ileum_metadata$Group,covariate = filt_ileum_metadata$Country, interaction = TRUE, sim.function = "robust.aitchison", p.adjust.m="BH")
pp_factor <- pp_main[[1]]
pp_cov <- pp_main[[2]]
pp_fac.cov <- pp_int[[3]]
cols <- c("pairs","Df","SumsOfSqs", "F.Model","R2","p.value", "p.adjusted", "sig")
colnames(pp_factor) <- cols; colnames(pp_cov) <- cols; colnames(pp_fac.cov) <- cols;
# save raw results
supplements[["PERMANOVA Aitchison ASV Ileum"]] <-rbind(pp_factor,pp_cov,pp_fac.cov)
# see the results
knitr::kable(pp_factor,digits = 3,caption = "PERMANOVA, GROUP separation")
knitr::kable(pp_cov,digits = 3,caption = "PERMANOVA, COUNTRY separation")
knitr::kable(pp_fac.cov,digits = 3,caption = "PERMANOVA, INTERACTION GROUP:Country")
interaction_sig <- pp_fac.cov$pairs[pp_fac.cov$p.adjusted < 0.05]
for (i in 1:length(interaction_sig)){
group1 <- unlist(strsplit(interaction_sig[i],split = " vs "))[1]
group2 <- unlist(strsplit(interaction_sig[i],split = " vs "))[2]
group2 <- unlist(strsplit(group2,split = " : "))[1]
result_list <- adonis_postanalysis(x=pairwise_df,
factors = filt_ileum_metadata$Group,
covariate = filt_ileum_metadata$Country,
group1 = group1,
group2 = group2)
print(result_list)
}
p <- pca_plot_custom(filt_ileum_asv_tab,
filt_ileum_taxa_tab,
filt_ileum_metadata,
show_boxplots = TRUE,
variable = "Group", size=3, show_legend=TRUE)
# save the results
supplements[["PCoA Aitchison Ileum ASV"]] <- p
# see the results
p
# preparing data frame
pairwise_df <- filt_ileum_asv_tab %>% column_to_rownames("SeqID") %>% t()
# main effect
pp_main <- pairwise.adonis(pairwise_df,filt_ileum_metadata$Group,covariate = filt_ileum_metadata$Country, sim.function = "bray", p.adjust.m="BH")
# interaction
pp_int <- pairwise.adonis(pairwise_df,filt_ileum_metadata$Group,covariate = filt_ileum_metadata$Country, interaction = TRUE, sim.function = "bray", p.adjust.m="BH")
pp_factor <- pp_main[[1]]
pp_cov <- pp_main[[2]]
pp_fac.cov <- pp_int[[3]]
cols <- c("pairs","Df","SumsOfSqs", "F.Model","R2","p.value", "p.adjusted", "sig")
colnames(pp_factor) <- cols; colnames(pp_cov) <- cols; colnames(pp_fac.cov) <- cols;
# save raw results
supplements[["PERMANOVA Bray ASV Ileum"]] <-rbind(pp_factor,pp_cov,pp_fac.cov)
# see the results
knitr::kable(pp_factor,digits = 3,caption = "PERMANOVA, GROUP separation")
knitr::kable(pp_cov,digits = 3,caption = "PERMANOVA, COUNTRY separation")
knitr::kable(pp_fac.cov,digits = 3,caption = "PERMANOVA, INTERACTION GROUP:Country")
interaction_sig <- pp_fac.cov$pairs[pp_fac.cov$p.adjusted < 0.05]
for (i in 1:length(interaction_sig)){
group1 <- unlist(strsplit(interaction_sig[i],split = " vs "))[1]
group2 <- unlist(strsplit(interaction_sig[i],split = " vs "))[2]
group2 <- unlist(strsplit(group2,split = " : "))[1]
result_list <- adonis_postanalysis(x=pairwise_df,
factors = filt_ileum_metadata$Group,
covariate = filt_ileum_metadata$Country,
group1 = group1,
group2 = group2,
sim.method = 'bray')
print(result_list)
}
p <- pca_plot_custom(filt_ileum_asv_tab,
filt_ileum_taxa_tab,
filt_ileum_metadata,
measure = "bray",
show_boxplots = TRUE,
variable = "Group", size=3, show_legend=TRUE)
# save the results
supplements[["PCoA Bray Ileum ASV"]] <- p
# see the results
p
# preparing data frame
pairwise_df <- filt_ileum_asv_tab %>% column_to_rownames("SeqID") %>% t()
# main effect
pp_main <- pairwise.adonis(pairwise_df,filt_ileum_metadata$Group,covariate = filt_ileum_metadata$Country, sim.function = "jaccard", p.adjust.m="BH")
# interaction
pp_int <- pairwise.adonis(pairwise_df,filt_ileum_metadata$Group,covariate = filt_ileum_metadata$Country, interaction = TRUE, sim.function = "jaccard", p.adjust.m="BH")
pp_factor <- pp_main[[1]]
pp_cov <- pp_main[[2]]
pp_fac.cov <- pp_int[[3]]
cols <- c("pairs","Df","SumsOfSqs", "F.Model","R2","p.value", "p.adjusted", "sig")
colnames(pp_factor) <- cols; colnames(pp_cov) <- cols; colnames(pp_fac.cov) <- cols;
# save raw results
supplements[["PERMANOVA Jaccard ASV Ileum"]] <-rbind(pp_factor,pp_cov,pp_fac.cov)
# see the results
knitr::kable(pp_factor,digits = 3,caption = "PERMANOVA, GROUP separation")
knitr::kable(pp_cov,digits = 3,caption = "PERMANOVA, COUNTRY separation")
knitr::kable(pp_fac.cov,digits = 3,caption = "PERMANOVA, INTERACTION GROUP:Country")
interaction_sig <- pp_fac.cov$pairs[pp_fac.cov$p.adjusted < 0.05]
for (i in 1:length(interaction_sig)){
group1 <- unlist(strsplit(interaction_sig[i],split = " vs "))[1]
group2 <- unlist(strsplit(interaction_sig[i],split = " vs "))[2]
group2 <- unlist(strsplit(group2,split = " : "))[1]
result_list <- adonis_postanalysis(x=pairwise_df,
factors = filt_ileum_metadata$Group,
covariate = filt_ileum_metadata$Country,
group1 = group1,
group2 = group2,
sim.method = 'jaccard')
print(result_list)
}
p <- pca_plot_custom(filt_ileum_asv_tab,
filt_ileum_taxa_tab,
filt_ileum_metadata,
measure = "jaccard",
show_boxplots = TRUE,
variable = "Group", size=3, show_legend=TRUE)
# save the results
supplements[["PCoA Jaccard Ileum ASV"]] <- p
# see the results
p
path="../intermediate_files/maaslin/Q1/Genus/"
genus_data <- aggregate_taxa(ileum_asv_tab,
ileum_taxa_tab,
taxonomic_level = "Genus")
ileum_genus_tab <- genus_data[[1]]
ileum_genus_taxa_tab <- genus_data[[2]]
ileum_genus_asv_taxa_tab <- create_asv_taxa_table(ileum_genus_tab,
ileum_genus_taxa_tab)
group <- c("healthy","pre_ltx")
# prepare the data
linda_data <- binomial_prep(ileum_genus_tab,
ileum_genus_taxa_tab,
ileum_metadata,
group, usage="linDA")
filt_ileum_uni_data <- linda_data[[1]]
filt_ileum_uni_taxa <- linda_data[[2]]
filt_ileum_uni_metadata <- linda_data[[3]]
# fit the model
linda.obj <- linda(filt_ileum_uni_data,
filt_ileum_uni_metadata,
formula = '~ Group * Country')
linda.output <- linda.obj$output
linda.output <- linda_renaming(linda.output, group)
# save the results
group1 <- paste0(group[1], " vs ","Group",group[2])
group2 <- paste0(group[1], " , ",group[2], " - CZ vs NO")
group3 <- paste0(group[1], " vs ","Group",group[2], ":CountryNO")
raw_linda_results_genus <- list();
raw_linda_results_genus[["terminal_ileum"]] <- list()
linda_results_genus <- list();
linda_results_genus[["terminal_ileum"]] <- list()
for (grp in c(group1,group2,group3)){
raw_linda_results_genus[["terminal_ileum"]][[grp]] <- rawlinda.df(linda.output,
grp,
filt_ileum_uni_data,
filt_ileum_uni_taxa)
linda_results_genus[["terminal_ileum"]][[grp]] <- linda.df(linda.output,
grp,
filt_ileum_uni_data,
filt_ileum_uni_taxa)
}
# summary statistics
raw_linda_results_genus <- binomial_statistics(filt_ileum_uni_data,
group=group,
filt_ileum_uni_metadata,
raw_linda_results_genus,
segment = "terminal_ileum")
# for comparison
new_name <- gsub("Group","",paste("linDA il G",group1))
addWorksheet(wb, sheetName = new_name)
genus_data <- aggregate_taxa(ileum_asv_tab,
ileum_taxa_tab,
taxonomic_level = "Genus")
ileum_genus_tab <- genus_data[[1]]
ileum_genus_taxa_tab <- genus_data[[2]]
group <- c("pre_ltx","healthy")
model_name <- paste(group[1],"vs",group[2],"Genus terminal_ileum")
# prepare the data
filt_ileum_uni_data <- binomial_prep(ileum_genus_tab,
ileum_genus_taxa_tab,
ileum_metadata,
group,
usage="glmnet")
data <- filt_ileum_uni_data
N = 10
## where to save relevant information
auc_validation <- vector('double', N)
accuracy_validation <- vector('double', N)
predictions <- vector("list", N)
conf_matrices <- vector("list", N)
kfold_rocobjs <- vector("list", N)
## original data in a matrix form
original_outcome <- base::as.matrix(data[[outcome]])
outcome="Group"
filt_ileum_uni_data
## original data in a matrix form
original_outcome <- base::as.matrix(data[[outcome]])
original_outcome
View(original_outcome)
if(!is.numeric(original_outcome)){
original_outcome <- factor(original_outcome)
mapping <- setNames(levels(original_outcome), 0:(length(levels(original_outcome))-1))
original_outcome <- as.numeric(factor(original_outcome)) - 1
}
original_predictors <- data %>%
dplyr::select(-dplyr::all_of(c(outcome,"Country",clust_var))) %>%
as.matrix()
clust_var=NULL
original_predictors <- data %>%
dplyr::select(-dplyr::all_of(c(outcome,"Country",clust_var))) %>%
as.matrix()
View(original_predictors)
colnames(original_predictors)
knn_model <- train(x = predictors, y = outcome, method = "knn",
tuneGrid = expand.grid(k = seq(1, 30, by = 1),
distance = c("uniform", "distance"),
p = c(1, 2)))
knn_model <- train(x = original_predictors, y = original_outcome, method = "knn",
tuneGrid = expand.grid(k = seq(1, 30, by = 1),
distance = c("uniform", "distance"),
p = c(1, 2)))
knn_model <- caret::train(x = original_predictors, y = original_outcome, method = "knn",
tuneGrid = expand.grid(k = seq(1, 30, by = 1),
distance = c("uniform", "distance"),
p = c(1, 2)))
knn_model <- caret::train(x = original_predictors, y = original_outcome, method = "knn",
tuneGrid = expand.grid(k = seq(1, 30, by = 1),
distance = c("uniform", "distance"),
p = c(1, 2)),
metric="AUC")
tuneGrid = expand.grid(k = seq(1, 30, by = 1),
distance = c("uniform", "distance"),
p = c(1, 2))
View(tuneGrid)
knn_model <- caret::train(x = original_predictors, y = original_outcome, method = "knn",
tuneGrid = expand.grid(k = seq(1, 30, by = 1),
distance = c("uniform", "distance"),
p = c(1, 2)),
metric="AUC")
knn_model <- caret::train(
x = original_predictors,
y = original_outcome,
method = "knn",
tuneGrid = expand.grid(k = seq(1, 30, by = 1),
distance = c("uniform", "distance"),
p = c(1, 2)),
metric="Accuracy")
knn_model <- caret::train(
x = original_predictors,
y = original_outcome,
method = "knn3",
tuneGrid = expand.grid(k = seq(1, 30, by = 1),
distance = c("uniform", "distance"),
p = c(1, 2)),
metric="Accuracy")
knn_model <- caret::train(
x = original_predictors,
y = original_outcome,
method = "knn",
tuneGrid = expand.grid(k = seq(1, 30, by = 1),
distance = c("uniform", "distance"),
p = c(1, 2)),
metric="Accuracy")
training_control <- trainControl(method = "repeatedcv",
summaryFunction = defaultSummary,
classProbs = TRUE,
number = 10,
repeats = 10)
knn_cv <- caret::train(x = original_predictors,
y = original_outcome,
method = "knn",
trControl = training_control,
metric = "Accuracy",
tuneGrid = data.frame(k = seq(11,85,by = 2)))
knn_cv <- caret::train(x = original_predictors,
y = original_outcome,
method = "knn",
trControl = training_control,
metric = "Accuracy",
tuneGrid = data.frame(k = seq(1,30,by = 1)))
knn_cv <- caret::train(x = original_predictors,
y = original_outcome,
method = "knn",
trControl = training_control,
metric = "Accuracy",
tuneGrid = data.frame(k = seq(1,30,by = 1)))
knn_model <- caret::train(
x = original_predictors,
y = original_outcome,
method = "knn",
tuneGrid = expand.grid(k = seq(1, 30, by = 1),
distance = c("uniform", "distance"),
p = c(1, 2)),
metric="Accuracy")
knn_model <- caret::train(
x = original_predictors,
y = original_outcome,
method = "knn",
tuneGrid = expand.grid(k = seq(1, 30, by = 1)),  # Only tuning k
metric = "Accuracy"  # Specify the evaluation metric for classification
)
# Directly pass the vector `y`
knn_model <- caret::train(
x = original_predictors,
y = original_outcome,
method = "knn",
tuneGrid = expand.grid(k = seq(1, 30, by = 1)),
metric = "Accuracy"
)
View(original_outcome)
as.factor(original_outcome)
# Directly pass the vector `y`
knn_model <- caret::train(
x = original_predictors,
y = as.factor(original_outcome),
method = "knn",
tuneGrid = expand.grid(k = seq(1, 30, by = 1)),
metric = "Accuracy"
)
# Directly pass the vector `y`
knn_model <- caret::train(
x = original_predictors,
y = as.factor(original_outcome),
method = "knn",  # Use kknn method for more flexibility
tuneGrid = expand.grid(k = seq(1, 30, by = 1),
distance = c(0, 1),  # 0 = uniform, 1 = distance weighting
p = c(1, 2)),  # Manhattan or Euclidean distance
metric = "Accuracy"  # Specify the evaluation metric
)
# Directly pass the vector `y`
knn_model <- caret::train(
x = original_predictors,
y = as.factor(original_outcome),
method = "knn",  # Use kknn method for more flexibility
tuneGrid = expand.grid(k = seq(1, 30, by = 1)),  # Manhattan or Euclidean distance
metric = "Accuracy"  # Specify the evaluation metric
)
a <- expand.grid(k = seq(1, 30, by = 1))
View(a)
# Directly pass the vector `y`
knn_model <- caret::train(
x = original_predictors,
y = as.factor(original_outcome),
method = "kknn",  # Use kknn method for more flexibility
tuneGrid = expand.grid(k = seq(1, 30, by = 1)),  # Manhattan or Euclidean distance
metric = "Accuracy"  # Specify the evaluation metric
)
# Directly pass the vector `y`
knn_model <- caret::train(
x = original_predictors,
y = as.factor(original_outcome),
method = "kknn",  # Use kknn method for more flexibility
tuneGrid = tune_grid,  # Manhattan or Euclidean distance
metric = "Accuracy"  # Specify the evaluation metric
)
tune_grid <- expand.grid(kmax = seq(1, 30, by = 1),  # Tuning the number of neighbors
distance = c(0, 1),  # 0 = uniform, 1 = distance weighting
kernel = c("rectangular", "triangular", "epanechnikov", "biweight", "cosine"))
# Directly pass the vector `y`
knn_model <- caret::train(
x = original_predictors,
y = as.factor(original_outcome),
method = "kknn",  # Use kknn method for more flexibility
tuneGrid = tune_grid,  # Manhattan or Euclidean distance
metric = "Accuracy"  # Specify the evaluation metric
)
tune_grid <- expand.grid(kmax = seq(1, 30, by = 1),  # Tuning the number of neighbors
distance = c(0, 1),  # 0 = uniform, 1 = distance weighting
kernel = c("rectangular", "triangular"))
# Directly pass the vector `y`
knn_model <- caret::train(
x = original_predictors,
y = as.factor(original_outcome),
method = "kknn",  # Use kknn method for more flexibility
tuneGrid = tune_grid,  # Manhattan or Euclidean distance
metric = "Accuracy"  # Specify the evaluation metric
)
warnings()
best_knn_model <- knn_model$bestTune
best_knn_model
knn_model$results
tune_grid <- expand.grid(kmax = seq(1, 30, by = 1),  # Tuning the number of neighbors
distance = c(1, 2),  # https://www.datacamp.com/tutorial/minkowski-distance
kernel = c("rectangular", "triangular"))
# Directly pass the vector `y`
knn_model <- caret::train(
x = original_predictors,
y = as.factor(original_outcome),
method = "kknn",  # Use kknn method for more flexibility
tuneGrid = tune_grid,  # Manhattan or Euclidean distance
metric = "Accuracy"  # Specify the evaluation metric
)
# Directly pass the vector `y`
knn_model <- caret::train(
x = original_predictors,
y = as.factor(original_outcome),
method = "kknn",  # Use kknn method for more flexibility
tuneGrid = tune_grid,  # Manhattan or Euclidean distance
metric = "AUC"  # Specify the evaluation metric
)
